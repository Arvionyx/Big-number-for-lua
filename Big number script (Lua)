local GNum={}
GNum.__index=GNum

function GNum:new(value,layers)
    local obj=setmetatable({},self)
    obj.value=value or nil
    obj.layers=layers or {}
    obj.cache={}
    return obj
end

local function cloneLayers(layers)
    local t={}
    for i,v in ipairs(layers) do
        t[i]={type=v.type,val=v.val,count=v.count}
    end
    return t
end

local function parseNumber(str,i,len)
    local j=i
    while j<=len and str:sub(j,j):match("%d") do j=j+1 end
    return tonumber(str:sub(i,j-1)),j
end

local function parseNotation(str,i,len)
    local c=str:sub(i,i)
    local j=i
    while j<=len and str:sub(j,j)==c do j=j+1 end
    local count=j-i
    return c,count,j
end

local function ensurePrevNumber(layers)
    local prev=layers[#layers]
    if not prev or prev.type~="num" then
        table.insert(layers,{type="num",val=1,count=1})
    end
end

function GNum:fromString(str)
    local layers={},i=1,len=#str
    while i<=len do
        local c=str:sub(i,i)
        if c:match("%d") then
            local num,j=parseNumber(str,i,len)
            table.insert(layers,{type="num",val=num,count=1})
            i=j
        elseif c=="e" or c=="F" or c=="G" then
            local n,count,j=parseNotation(str,i,len)
            i=j
            ensurePrevNumber(layers)
            local nextNum=1
            if i<=len and str:sub(i,i):match("%d") then
                nextNum,j=parseNumber(str,i,len)
                i=j
            end
            for k=1,count do
                table.insert(layers,{type=n,val=nextNum,count=1})
            end
        else
            i=i+1
        end
    end
    local revLayers={}
    for k=#layers,1,-1 do revLayers[#revLayers+1]=layers[k] end
    return GNum:new(nil,revLayers)
end

local function layerToString(l)
    if l.type=="num" then return tostring(l.val)
    elseif l.type=="e" then return string.rep("e",l.count)..l.val
    elseif l.type=="F" then return string.rep("F",l.count)..l.val
    elseif l.type=="G" then return string.rep("G",l.count)..l.val
    elseif l.type=="pow" then return "^("..l.val:toString()..")"
    else return l.type.."("..l.val:toString()..")"
    end
end

function GNum:toString()
    local parts={}
    for _,l in ipairs(self.layers) do parts[#parts+1]=layerToString(l) end
    return table.concat(parts)
end

local function estimateLayerMag(l)
    if l.type=="num" then return l.val
    elseif l.type=="e" then return 10^(l.val)
    elseif l.type=="F" then return l.val
    elseif l.type=="G" then return l.val*10
    elseif l.type=="pow" then return l.val:estimateMag()
    else return l.val:estimateMag()
    end
end

function GNum:estimateMag()
    if self.value then return self.value end
    local mag=1
    for _,l in ipairs(self.layers) do
        mag=mag*estimateLayerMag(l)
    end
    return mag
end

function GNum:add(other)
    local newLayers=cloneLayers(self.layers)
    for _,l in ipairs(other.layers) do newLayers[#newLayers+1]=l end
    return GNum:new(nil,newLayers)
end

function GNum:mul(other)
    local newLayers=cloneLayers(self.layers)
    for _,l in ipairs(other.layers) do newLayers[#newLayers+1]=l end
    return GNum:new(nil,newLayers)
end

function GNum:pow(other)
    local newLayers=cloneLayers(self.layers)
    newLayers[#newLayers+1]={type="pow",val=other}
    return GNum:new(nil,newLayers)
end

function GNum:log() return GNum:new(nil,{{type="log",val=self}}) end
function GNum:exp() return GNum:new(nil,{{type="exp",val=self}}) end
function GNum:sqrt() return GNum:new(nil,{{type="sqrt",val=self}}) end
function GNum:cbrt() return GNum:new(nil,{{type="cbrt",val=self}}) end
function GNum:sin() return GNum:new(nil,{{type="sin",val=self}}) end
function GNum:cos() return GNum:new(nil,{{type="cos",val=self}}) end
function GNum:tan() return GNum:new(nil,{{type="tan",val=self}}) end

function GNum:tetrate(times)
    if not times.value or times.value<=1 then return self end
    return GNum:new(nil,{{type="pow",val=self},{type="tetrate",val:self:tetrate(GNum:new(times.value-1))}})
end

function GNum:pentate(times)
    if not times.value or times.value<=1 then return self end
    return GNum:new(nil,{{type="pow",val=self},{type="pentate",val:self:pentate(GNum:new(times.value-1))}})
end

function GNum:normalizeLayers()
    local newLayers={}
    for _,l in ipairs(self.layers) do
        if l.type=="num" and l.val==0 then
            newLayers[#newLayers+1]={type="num",val=1,count=1}
        else
            newLayers[#newLayers+1]=l
        end
    end
    self.layers=newLayers
end

local test_inputs={"6Fee9","1FF5","FF9","F9","ee9","1G5","2GG3","3FFee6","2G7","5FFe9","4FFee9"}
for _,s in ipairs(test_inputs) do
    local n=GNum:fromString(s)
    n:normalizeLayers()
    print(s.." -> "..n:toString().." | mag~"..n:estimateMag())
end

local pent_test=GNum:fromString("2G7")
local pent_calc=pent_test:pentate(GNum:fromString("1"))
print("2G7 pentation symbolic -> "..pent_calc:toString())

local a=GNum:fromString("3F1e9")
local b=GNum:fromString("2F2e8")
local c=a:add(b)
print("Addition symbolic -> "..c:toString())
local d=a:mul(b)
print("Multiplication symbolic -> "..d:toString())
local e=a:pow(b)
print("Exponentiation symbolic -> "..e:toString())
local f=a:tetrate(GNum:fromString("2"))
print("Tetration symbolic -> "..f:toString())
