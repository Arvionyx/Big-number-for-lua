-- big_ext.lua
local Big={};Big.__index=Big
local PREC=60
local safe_wrap=function(f)return function(...) local ok,res=pcall(f,...) if ok then return res else return nil,res end end end
local trim_lz=safe_wrap(function(s)return(s:gsub("^0+","")=="") and "0" or s:gsub("^0+","")end)
local trim_tz=safe_wrap(function(s)return(s:gsub("0+$",""))end)
local normalize=safe_wrap(function(o)o.int=trim_lz(o.int)o.frac=trim_tz(o.frac)if o.int=="0" and o.frac=="" then o.sign=1 end return o end)
local is_zero_raw=function(o)return o.int=="0" and (o.frac==nil or o.frac=="") end
local clone_raw=function(x)return Big.new((x.sign==-1 and "-" or "")..x.int..(#x.frac>0 and "."..x.frac or "")) end

Big.new=safe_wrap(function(x)
 if getmetatable(x)==Big then return x end
 local s=tostring(x);local sign=1
 if s:sub(1,1)=="-" then sign=-1;s=s:sub(2) end
 if s:sub(1,1)=="+" then s=s:sub(2) end
 local base,exp=s:match("^(.+)[eE]([+-]?%d+)$")
 if base then
   exp=tonumber(exp)
   local i,f=base:match("(%d*)%.?(%d*)");i=i=="" and "0" or i;f=f or ""
   local c=i..f;local p=#i+exp
   if p<=0 then return setmetatable({int="0",frac=trim_tz(string.rep("0",-p)..c),sign=sign},Big)
   elseif p>=#c then return setmetatable({int=trim_lz(c..string.rep("0",p-#c)),frac="",sign=sign},Big)
   else return setmetatable({int=trim_lz(c:sub(1,p)),frac=trim_tz(c:sub(p+1)),sign=sign},Big) end
 end
 local i,f=s:match("(%d*)%.?(%d*)");i=i=="" and "0" or i;f=f or ""
 return normalize({int=trim_lz(i),frac=trim_tz(f),sign=sign})
end)

local cmp_abs=safe_wrap(function(a,b)
 if #a.int~=#b.int then return #a.int>#b.int and 1 or -1 end
 if a.int~=b.int then return a.int>b.int and 1 or -1 end
 local L=math.max(#a.frac,#b.frac)
 for i=1,L do local da=tonumber(a.frac:sub(i,i)or"0");local db=tonumber(b.frac:sub(i,i)or"0");if da~=db then return da>db and 1 or -1 end end
 return 0
end)

local add_abs=safe_wrap(function(a,b)
 local af,bf=a.frac,b.frac;local ai,bi=a.int,b.int
 local fl=math.max(#af,#bf);af=af..string.rep("0",fl-#af);bf=bf..string.rep("0",fl-#bf)
 local carry=0;local fd={}
 for i=fl,1,-1 do local s=tonumber(af:sub(i,i))+tonumber(bf:sub(i,i))+carry;carry=math.floor(s/10);fd[i]=tostring(s%10) end
 local frac=table.concat(fd)
 local il=math.max(#ai,#bi);ai=string.rep("0",il-#ai)..ai;bi=string.rep("0",il-#bi)..bi
 local id={}
 for i=il,1,-1 do local s=tonumber(ai:sub(i,i))+tonumber(bi:sub(i,i))+carry;carry=math.floor(s/10);id[i]=tostring(s%10) end
 local int=(carry>0 and tostring(carry) or "")..table.concat(id)
 return trim_lz(int),trim_tz(frac)
end)

local sub_abs=safe_wrap(function(a,b)
 local af,bf=a.frac,b.frac;local ai,bi=a.int,b.int
 local fl=math.max(#af,#bf);af=af..string.rep("0",fl-#af);bf=bf..string.rep("0",fl-#bf)
 local borrow=0;local fd={}
 for i=fl,1,-1 do local x=tonumber(af:sub(i,i))-tonumber(bf:sub(i,i))-borrow;if x<0 then x=x+10;borrow=1 else borrow=0 end fd[i]=tostring(x) end
 local frac=table.concat(fd)
 local il=math.max(#ai,#bi);ai=string.rep("0",il-#ai)..ai;bi=string.rep("0",il-#bi)..bi
 local id={}
 for i=il,1,-1 do local x=tonumber(ai:sub(i,i))-tonumber(bi:sub(i,i))-borrow;if x<0 then x=x+10;borrow=1 else borrow=0 end id[i]=tostring(x) end
 return trim_lz(table.concat(id)),trim_tz(frac)
end)

local grade_mul=safe_wrap(function(A,B)
 if A=="0" or B=="0" then return "0" end
 local aL,bL=#A,#B;local res={};for i=1,aL+bL do res[i]=0 end
 for i=aL,1,-1 do local ai=tonumber(A:sub(i,i)) for j=bL,1,-1 do local bj=tonumber(B:sub(j,j)) res[i+j]=res[i+j]+ai*bj end end
 for i=aL+bL,2,-1 do local c=math.floor(res[i]/10);res[i]=res[i]%10;res[i-1]=res[i-1]+c end
 local s=table.concat(res):gsub("^0+","");return(s=="" and "0" or s)
end)

local karatsuba=safe_wrap(function(A,B) return grade_mul(A,B) end)

Big.add=safe_wrap(function(self,other)
 other=Big.new(other)
 if self.sign==other.sign then local i,f=add_abs(self,other) return Big.new((self.sign==-1 and "-" or "")..i..(#f>0 and "."..f or "")) end
 local c=cmp_abs(self,other)
 if c==0 then return Big.new("0") end
 if c>0 then local i,f=sub_abs(self,other) return Big.new((self.sign==-1 and "-" or "")..i..(#f>0 and "."..f or "")) else local i,f=sub_abs(other,self) return Big.new((other.sign==-1 and "-" or "")..i..(#f>0 and "."..f or "")) end
end)

Big.sub=safe_wrap(function(self,other) other=Big.new(other);other.sign=-other.sign;return Big.add(self,other) end)

Big.mul=safe_wrap(function(self,other)
 other=Big.new(other)
 if is_zero_raw(self) or is_zero_raw(other) then return Big.new("0") end
 local A=self.int..self.frac;local B=other.int..other.frac
 local decimals=#self.frac+#other.frac
 local prod=(#A+#B>80*2) and karatsuba(A,B) or grade_mul(A,B)
 if prod=="0" then return Big.new("0") end
 if decimals>0 then if #prod<=decimals then prod=string.rep("0",decimals-#prod+1)..prod end
  local intp=prod:sub(1,#prod-decimals);local fracp=prod:sub(#prod-decimals+1)
  return Big.new((self.sign*other.sign==-1 and "-" or "")..trim_lz(intp).."."..trim_tz(fracp))
 else return Big.new((self.sign*other.sign==-1 and "-" or "")..prod) end
end)

local function divmod_int_raw(A,B)
 A=trim_lz(A);B=trim_lz(B)
 if B=="0" then error("divmod by zero") end
 if A=="0" or (#A<#B or (#A==#B and A<B)) then return "0",A end
 if A==B then return "1","0" end
 local q={};local r=""
 for idx=1,#A do r=r..A:sub(idx,idx);r=trim_lz(r);if r=="" then r="0" end
  local t=0;while not (#r<#B or (#r==#B and r<B)) do r=Big.new(r):sub(Big.new(B)).int;r=(r=="" and "0" or r);t=t+1 end;q[#q+1]=tostring(t) end
 return trim_lz(table.concat(q)),trim_lz(r)
end

Big.div=safe_wrap(function(self,other,prec)
 prec=prec or PREC;other=Big.new(other)
 if is_zero_raw(other) then error("div by zero") end
 local shift=math.max(#self.frac,#other.frac)
 local Aint=self.int..self.frac..string.rep("0",shift-#self.frac)
 local Bint=other.int..other.frac..string.rep("0",shift-#other.frac)
 local numer=Aint..string.rep("0",prec)
 local q,r=divmod_int_raw(numer,Bint)
 if #q<=prec then q=string.rep("0",prec-#q+1)..q end
 local intp=q:sub(1,#q-prec);local fracp=q:sub(#q-prec+1)
 local sign=(self.sign*other.sign==-1) and "-" or ""
 return Big.new(sign..trim_lz(intp).."."..trim_tz(fracp))
end)

Big.divmod=safe_wrap(function(self,other) other=Big.new(other) if is_zero_raw(other) then error("divmod by zero") end local q,r=divmod_int_raw(self.int..self.frac,other.int..other.frac);return Big.new(trim_lz(q)),Big.new(trim_lz(r)) end)
Big.mod=safe_wrap(function(self,other)local q,r=Big.divmod(self,other)return r end)

Big.pow_int=safe_wrap(function(self,exp)
 if getmetatable(exp)==Big then if exp.frac~="" then error("non-int exponent") end;exp=tonumber(exp.int) end
 exp=tonumber(exp)
 if exp<0 then error("negative exponent") end
 local base=clone_raw(self);local res=Big.new("1");local e=exp
 while e>0 do if e%2==1 then res=res:mul(base) end; e=math.floor(e/2);if e>0 then base=base:mul(base) end end
 return res
end)

Big.toString=safe_wrap(function(self) normalize(self);return self.frac~="" and (self.int.."."..self.frac) or self.int end)
Big.toScientific=safe_wrap(function(self,digits)
 digits=digits or 10;if is_zero_raw(self) then return "0e0" end
 local s=self.int..self.frac;local exp=#self.int-1
 local m=s:sub(1,digits);local r=m:sub(2)
 if r=="" then r=string.rep("0",digits-1) end
 local sign=(self.sign==-1) and "-" or ""
 return string.format("%s%s.%se%d",sign,m:sub(1,1),r,exp)
end)

setmetatable(Big,{__call=function(_,x)return Big.new(x) end})
return Big

